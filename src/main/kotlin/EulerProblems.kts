package euler

/**
 * Problem 1
 * If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
 * The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.
 *
 * Solution: 233168
 */
fun problem1() = println((1..999).filter{ it % 3 == 0 || it % 5 == 0 }.sum())
//problem1()

/**
 * Problem 2
 * <p>
 * Each new term in the Fibonacci sequence is generated by adding the previous two terms.
 * By starting with 1 and 2, the first 10 terms will be:
 * <p>
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
 * <p>
 * By considering the terms in the Fibonacci sequence whose values do not exceed four million,
 * find the sum of the even-valued terms.
 * <p>
 * Solution: 4613732
 */
fun problem2() = println(fibUpTo(4000000).filter { it % 2 == 0L }.sum())
//problem2()

/**
 * Problem 3
 * <p>
 * The prime factors of 13195 are 5, 7, 13 and 29.
 * What is the largest prime factor of the number 600851475143 ?
 * <p>
 * Result should be 6857
 */
fun problem3() = println(primeFactors(600851475143).last())
//problem3()

/**
 * Problem 4
 * A palindromic number reads the same both ways.
 * The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
 *
 * Find the largest palindrome made from the product of two 3-digit numbers.
 *
 * The result should be numbers 993 and 913, that multiplied make 906609
 */
fun problem4() {
  val factors = (2..999)
  var left = 0
  var right = 0
  var product = 0

  factors.forEach({ i ->
    factors.forEach({ j ->
      val result = (i * j).toString()
      if(result == result.reversed() && i * j > product) {
        left = i
        right = j
        product = i * j
      }
    })
  })
  println("${left} * ${right} = ${product}")
}
//problem4()

/**
 * Problem 5
 * 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
 * What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
 *
 * The answer should be 232792560
 */
fun problem5() {
  for(i in (2521..Int.MAX_VALUE)) {
    var isSolution = true
    (1..20).forEach({
      if(i % it != 0) {
        isSolution = false
      }
    })
    if(isSolution) {
      println(i)
      kotlin.system.exitProcess(0)
    }
  }
}
//problem5()

/**
 * Problem 6
 *
 * The sum of the squares of the first ten natural numbers is
 * 1^2 + 2^2 + ... + 10^2 = 385
 *
 * The square of the sum of the first ten natural numbers is,
 * (1 + 2 + ... + 10)^2 = 552 = 3025
 *
 * Hence the difference between the sum of the squares of the first ten natural numbers
 * and the square of the sum is 3025 − 385 = 2640.
 *
 * Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
 *
 * Notes:
 *
 * the sum of squares is a square pyramidal number.
 *   See https://en.wikipedia.org/wiki/Square_pyramidal_number and https://oeis.org/A000330.
 *
 * The formula for square pyramidal numbers is
 *
 *   n(n + 1)(2n + 1)
 *   ----------------
 *         6
 *
 * The sum of 1..n is (n(n+1) / 2)
 *
 * The result should be 25164150 (sumOfSq = 338350, sqOfSum = 25502500)
 *
 */
fun problem6() {
  val squareOfSum = Math.pow(100 * 101 / 2.0, 2.0).toLong()
  val sumOfSquares = 100 * 101 * 201 / 6
  println(squareOfSum - sumOfSquares)
}

/**
 * Problem
 *
 * By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
 * What is the 10 001st prime number?
 *
 * Methods to determine primality (see https://en.wikipedia.org/wiki/Primality_test):
 *
 * 1. Trial division. Simplest but computationally intensive.
 *     For an input n, test that n / 2..sqrt(n) always gives a remainder. If there's a remainder == 0, the number is NOT prime.
 *
 * 2. Test remainder for 2 and 3. Then, test remainder for n / p where p is all numbers (6k +- 1) < sqrt(n), and k = integers
 *
 * The answer is 104743
 */

// helper functions
fun isPrimeByDivision(n: Long): Boolean {
  (2..Math.sqrt(n)).forEach(
    if(n % it == 0) return false
    return true
  )
}

fun fibUpTo(roof: Long): MutableList<Long> {
  var twoBefore = 0L
  var oneBefore = 1L
  var thisOne: Long

  val l = mutableListOf(0L, 1L)

  while(true) {
    thisOne = twoBefore + oneBefore
    if(thisOne < roof) {
      twoBefore = oneBefore
      oneBefore = thisOne
      l.add(thisOne)
    }
    else break;
  }
  // Goes one over the roof by one fib number
  return l
}

fun primeFactors(number: Long): MutableList<Long> {
  var n = number
  var i = 2L
  val l = mutableListOf(1L)

  while(i <= n) {
    if(n % i == 0L) {
      l.add(i)
      n = n / i
    }
    else {
      i++
    }
  }
  return l
}
