package euler

import java.util.stream.Collectors
import kotlin.math.pow
import kotlin.system.exitProcess

/**
 * Problem 1
 * If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
 * The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.
 *
 * Solution: 233168
 */
fun problem1() = println((1..999).filter{ it % 3 == 0 || it % 5 == 0 }.sum())
//problem1()

/**
 * Problem 2
 * <p>
 * Each new term in the Fibonacci sequence is generated by adding the previous two terms.
 * By starting with 1 and 2, the first 10 terms will be:
 * <p>,
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
 * <p>
 * By considering the terms in the Fibonacci sequence whose values do not exceed four million,
 * find the sum of the even-valued terms.
 * <p>
 * Solution: 4613732
 */
fun problem2() = println(fibUpTo(4000000).filter { it % 2 == 0L }.sum())
//problem2()

/**
 * Problem 3
 * <p>
 * The prime factors of 13195 are 5, 7, 13 and 29.
 * What is the largest prime factor of the number 600851475143 ?
 * <p>
 * Result should be 6857
 */
fun problem3() = println(primeFactors(600851475143).last())
//problem3()

/**
 * Problem 4
 * A palindromic number reads the same both ways.
 * The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
 *
 * Find the largest palindrome made from the product of two 3-digit numbers.
 *
 * The result should be numbers 993 and 913, that multiplied make 906609
 */
fun problem4() {
  val factors = (2..999)
  var left = 0
  var right = 0
  var product = 0

  factors.forEach({ i ->
    factors.forEach({ j ->
      val result = (i * j).toString()
      if(result == result.reversed() && i * j > product) {
        left = i
        right = j
        product = i * j
      }
    })
  })
  println("${left} * ${right} = ${product}")
}
//problem4()

/**
 * Problem 5
 * 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
 * What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
 *
 * The answer should be 232792560
 */
fun problem5() {
  for(i in (2521..Int.MAX_VALUE)) {
    var isSolution = true
    (1..20).forEach({
      if(i % it != 0) {
        isSolution = false
      }
    })
    if(isSolution) {
      println(i)
      kotlin.system.exitProcess(0)
    }
  }
}
fun problem5_2() {
  var list = ArrayList<Long>()
  (11..20).forEach {
    list.addAll(primeFactors(it.toLong()))
  }
  println(list.stream().reduce(1, (a, b) -> a * b))
}
//problem5()
problem5_2()

/**
 * Problem 6
 *
 * The sum of the squares of the first ten natural numbers is
 * 1^2 + 2^2 + ... + 10^2 = 385
 *
 * The square of the sum of the first ten natural numbers is,
 * (1 + 2 + ... + 10)^2 = 552 = 3025
 *
 * Hence the difference between the sum of the squares of the first ten natural numbers
 * and the square of the sum is 3025 − 385 = 2640.
 *
 * Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
 *
 * Notes:
 *
 * the sum of squares is a square pyramidal number.
 *   See https://en.wikipedia.org/wiki/Square_pyramidal_number and https://oeis.org/A000330.
 *
 * The formula for square pyramidal numbers is
 *
 *   n(n + 1)(2n + 1)
 *   ----------------
 *         6
 *
 * The sum of 1..n is (n(n+1) / 2)
 *
 * The result should be 25164150 (sumOfSq = 338350, sqOfSum = 25502500)
 *
 */
fun problem6() {
  val squareOfSum = Math.pow(100 * 101 / 2.0, 2.0).toLong()
  val sumOfSquares = 100 * 101 * 201 / 6
  println(squareOfSum - sumOfSquares)
}
//problem6()

/**
 * Problem 7
 *
 * By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
 * What is the 10,001st prime number?
 *
 * Methods to determine primality (see https://en.wikipedia.org/wiki/Primality_test):
 * Note: 1 is NOT a prime
 *
 * 1. Trial division. Simplest but computationally intensive.
 *     For an input n, test that n / 2..sqrt(n) always gives a remainder. If there's a remainder == 0, the number is NOT prime.
 *
 * 2. Test remainder for 2 and 3. Then, test remainder for n / p where p is all numbers (6k +- 1) < sqrt(n), and k = integers
 *
 * The answer is 104743
 */
fun problem7() {
  var count:Int = 0

  (2..Int.MAX_VALUE).forEach {
    if(isPrimeByDivision(it) && count <= 10001) count++
    if(count == 10001) {
      println(it)
      exitProcess(0)
    }
  }
}
//problem7()

/**
 * Problem 8
 * <p>
 * The four adjacent digits in the 1000-digit number below that have the greatest product are 9 × 9 × 8 × 9 = 5832.
 * Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
 * <p>
 * 73167176531330624919225119674426574742355349194934
 * 96983520312774506326239578318016984801869478851843
 * 85861560789112949495459501737958331952853208805511
 * 12540698747158523863050715693290963295227443043557
 * 66896648950445244523161731856403098711121722383113
 * 62229893423380308135336276614282806444486645238749
 * 30358907296290491560440772390713810515859307960866
 * 70172427121883998797908792274921901699720888093776
 * 65727333001053367881220235421809751254540594752243
 * 52584907711670556013604839586446706324415722155397
 * 53697817977846174064955149290862569321978468622482
 * 83972241375657056057490261407972968652414535100474
 * 82166370484403199890008895243450658541227588666881
 * 16427171479924442928230863465674813919123162824586
 * 17866458359124566529476545682848912883142607690042
 * 24219022671055626321111109370544217506941658960408
 * 07198403850962455444362981230987879927244284909188
 * 84580156166097919133875499200524063689912560717606
 * 05886116467109405077541002256983155200055935729725
 * 71636269561882670428252483600823257530420752963450
 * <p>
 * The result is 23514624000
 */
fun problem8() {
  val theNumber = "73167176531330624919225119674426574742355349194934" +
    "96983520312774506326239578318016984801869478851843" +
    "85861560789112949495459501737958331952853208805511" +
    "12540698747158523863050715693290963295227443043557" +
    "66896648950445244523161731856403098711121722383113" +
    "62229893423380308135336276614282806444486645238749" +
    "30358907296290491560440772390713810515859307960866" +
    "70172427121883998797908792274921901699720888093776" +
    "65727333001053367881220235421809751254540594752243" +
    "52584907711670556013604839586446706324415722155397" +
    "53697817977846174064955149290862569321978468622482" +
    "83972241375657056057490261407972968652414535100474" +
    "82166370484403199890008895243450658541227588666881" +
    "16427171479924442928230863465674813919123162824586" +
    "17866458359124566529476545682848912883142607690042" +
    "24219022671055626321111109370544217506941658960408" +
    "07198403850962455444362981230987879927244284909188" +
    "84580156166097919133875499200524063689912560717606" +
    "05886116467109405077541002256983155200055935729725" +
    "71636269561882670428252483600823257530420752963450"

  var result:Long = 0
  (0..987).forEach {
    val numbers = (theNumber.substring(it..it + 12).map { Character.getNumericValue(it).toLong() })
    val product = numbers.fold(1L, { number, last -> number * last })
    if (product > result) result = product
  }
  println(result)
}
//problem8()




// helper functions
fun fibUpTo(roof: Long): MutableList<Long> {
  var twoBefore = 0L
  var oneBefore = 1L
  var thisOne: Long

  val l = mutableListOf(0L, 1L)

  while(true) {
    thisOne = twoBefore + oneBefore
    if(thisOne < roof) {
      twoBefore = oneBefore
      oneBefore = thisOne
      l.add(thisOne)
    }
    else break;
  }
  // Goes one over the roof by one fib number
  return l
}

fun primeFactors(number: Long): MutableList<Long> {
  var n = number
  var i = 2L
  val l = mutableListOf(1L)

  while(i <= n) {
    if(n % i == 0L) {
      l.add(i)
      n = n / i
    }
    else {
      i++
    }
  }
  return l
}

fun isPrimeByDivision(n: Int): Boolean {
  if(n in (1..3)) return true
  val roof = Math.sqrt(n.toDouble()).toInt()
  (2..roof).forEach {
    if(n % it == 0) return false
  }
  return true
}
